var Q        = require('q');
var AdmZip   = require('adm-zip');
var sax      = require('sax');
var beautify = require('js-beautify').html;
var defaults = require('lodash.defaults');

var util         = require('./util');
var openFilters  = require('./conversion');
var closeFilters = require('./closing');
var styleFilters = require('./styling');

function generateFootnotes(footnotes) {
    var html = '';

    footnotes.list.forEach(function(footnote) {
        html += '<p><sup id="footnote-'+footnote.id+'">';
        html += footnote.body;
        html += '<a href="#footnote-ref-'+footnote.id+'">&uarr;</a>';
        html += '</sup></p>';
    });

    return html;
}

// Main convert function
function toHTML(opts) {
    var d = Q.defer();

    // Check path
    if (!opts.path) {
        d.reject(new Error('Path to the source document is missing.'));
    }

    // Add custom filters to openFilters
    if (opts.openFilters) {
        openFilters = defaults(openFilters, opts.openFilters);
    }
    // Add custom filters to closeFilters
    if (opts.closeFilters) {
        closeFilters = defaults(closeFilters, opts.closeFilters);
    }

    // Add custome filters to styleFilters
    if (opts.styleFilters) {
        styleFilters = defaults(styleFilters, opts.styleFilters);
    }

    // Create styles table
    var styles = {
        // Initialize for blockquotes
        text: {
            'Quotations': [ 'blockquote' ]
        },
        // Initialize for lists for text:list-style
        lists: {
            openedTags: []
        },
        currentStyle: null
    };

    // Create footnotes
    var footnotes = {
        onId:    false,
        onBody:  false,
        current: null,
        list:    []
    };

    // Create frames record
    var frames = {
        current: null
    };

    // Read ODT file
    var odt;
    try {
        odt = new AdmZip(opts.path);
    } catch(err) {
        d.reject(err);
    }
    if (!odt) {
        d.reject(new Error('Unknown error while reading content of OpenOffice document.'));
    }

    // Extract content
    var contentFile = odt.getEntry('content.xml');
    if (!contentFile) {
        d.reject(new Error('Invalid OpenOffice document structure.'));
    }
    var xmlContent = contentFile.getData().toString();

    // Output
    var html = '';
    var openedTags = [];
    var stylingTags = [];

    // Configure parser
    var saxParser = sax.parser(true, {
        normalize: true
    });

    saxParser.onopentag = function(node) {
        // Don't process footnotes body
        if (footnotes.onBody) {
            return;
        }

        // Process styles
        var processStyle = styleFilters[node.name];
        if (!!processStyle && typeof processStyle == 'function') {
            processStyle(node, styles);
            return;
        }

        // Get tag info from openFilters
        var processNode = openFilters[node.name];

        // Tag not supported
        if (!processNode || typeof processNode != 'function') {
            return;
        }

        // Process current node/tag
        var tag = processNode(node, styles, footnotes, frames, opts, odt);
        // No tag returned -> don't process to HTML
        if (!tag) {
            return;
        }

        // Tag is a string, append to HTML
        if (typeof tag == 'string') {
            html += tag;
            return;
        }

        // Add to list of opened tags
        if (!tag.isSelfClosing) {
            openedTags.push(tag);
        }
        // Add to HTML output
        html += util.openTag(tag.html, tag.attrs, tag.isSelfClosing);

        // Apply text decoration styling
        var nodeStyleName = node.attributes['text:style-name'];
        var nodeStyles = styles.text[nodeStyleName];
        // Apply each style tag to the current element
        if (!!nodeStyles && !!nodeStyles.length) {
            nodeStyles.forEach(function(styleTag) {
                stylingTags.push(styleTag);
                html += util.openTag(styleTag);
            });
        }
    };

    saxParser.onclosetag = function(tag) {
        // Close current style if done
        if (tag == 'style:style' || tag == 'text:list-style') {
            styles.currentStyle = null;
            return;
        }

        // Close previously opened styling tags
        while (!!stylingTags.length) {
            var styleTag = stylingTags.pop();
            html += util.closeTag(styleTag);
        }

        // Handle closing
        var processNode = closeFilters[tag];
        if (!!processNode && typeof processNode == 'function') {
            processNode(styles, footnotes, frames, opts, odt);
        }

        // Don't process footnotes body
        if (footnotes.onBody) {
            return;
        }

        // Close HTML tag if needed
        if (!openedTags.length) {
            return;
        }

        var lastTag = openedTags.pop();
        if (lastTag.xml == tag && !lastTag.isSelfClosing) {
            html += util.closeTag(lastTag.html);
        } else {
            // Unmatching open and closing tags
            openedTags.push(lastTag);
        }
    };

    saxParser.ontext = function(text) {
        // Read a footnote id
        if (footnotes.onId) {
            footnotes.current = {
                id: text,
                body: ''
            };
            return;
        }

        // Read a footnote body
        if (footnotes.onBody) {
            footnotes.current.body += text;
            return;
        }

        // Append simple text
        html += text;
    };

    saxParser.onerror = function(err) {
        console.log('Parsing error: ', err);
        d.reject(err);
    };

    saxParser.onend = function() {
        // Append footnotes
        html += generateFootnotes(footnotes);

        if (opts.beautify) {
            html = beautify(html);
        }
        d.resolve(html);
    };

    // Feed parser
    saxParser.write(xmlContent).close();

    return d.promise;
}

module.exports = {
    toHTML: toHTML
};